
max_col_num = 100
max_row_num = 100

# skip this many rows before reading in header and data
skip_rows        = 0

# is there a header line that identifies the columns?
header           = yes

# is there a row that specifies the order of columns in the image?
# - if so, this must be the first line of the header
col_order_row     = no
use_col_order_row = no

# is there a row that specifies the color of each column segment in the image?
# - if so, this must be the second column
col_color_row     = no
use_col_color_row = no

# is there a column that specifies the order of rows in the image?
# - if so, this must be the first column
row_order_col     = no
use_row_order_col = no

# is there a column that specifies the color of each row segment in the image?
# - if so, this must be the second column
row_color_col     = no
use_row_color_col = no

# if you do not have a column/row that explicitly defines order
# of segments in the image, you can set this here to
# - row_major (row segments first, then column)
# - col_major (col segments first, then row)
# - ascii     (asciibetic order)
# - size_asc  (size, in ascending order)
# - size_desc (size, in descending order)

segment_order = row_major,size_desc

################################################################
# placement of cell ribbons on row/column segments
# 
# for segments that share both column and row ribbons, the
# order of ribbon position can be adjusted with placement_order

placement_order = row,col # col,row or row,col

# within the row/column ribbon bundle for each segment, 
# ribbon_bundle_order determines how the ribbons will be
# ordered
# - size, by value of the cell
# - ascii - sorted by destination label
# - native - sorted by order of destination segment
ribbon_bundle_order = size # size, ascii, native

# reverse the position of links in table/row segments?
reverse_rows    = yes
reverse_columns = yes

# do not report any data for cells with row/col having the same label
intra_cell_exclude     = no
# remove any such same-label data from row/col segment size
intra_cell_size_remove = no

################################################################
# scale your values with a power rule (useful if the range of values
# is very large) to
# - atten_large: attenuate large values and maintain visibility
#   of ribbons corresponding to small values, or
# - atten_small: attenuate small values to increase visibility
#   of ribbons corresponding to large values
#
# given a value, v, and a maximum, m
#
# atten_small:
#
# v_new = m * ( exp(scale_factor * v / m) - 1 ) / ( exp(scale_factor) - 1 )
#
# atten_large:
#
# v_new = m * 
# 
# essentially the values are remapped to a log-type scale 
# with the range 0..m

use_scaling    = no
scaling_type   = atten_large
scale_factor   = 1

missing_cell_value = -

################################################################
# Value cutoffs for cell values and ribbon formatting.
#
# You can toggle the visibility of ribbons for cells outside
# a min/max range. You can define one or more of these cutoffs.
# The cutoffs are applied to unscaled cell values.

#cell_min_value      = 0
#cell_min_percentile = 10
#cell_max_value      = 100
#cell_max_percentile = 100

# The color of ribbons is by default the color of the row segment from
# which they originate. The block below allows you to remap the color
# of the ribbons based on cell percentile values. There are two ways
# to remap colors
# 
# - color_remap=yes, color_autoremap=no
#   Uses <percentile> blocks to define the percentile values and associated
#   color/stroke_color characteristics for ribbons. Percentile value defined
#   in the block (e.g. <percentile 55>) is the max percentile value for
#   cells associated with this block.
# - color_remap=yes, color_autoremap=yes
#   Uses colors associated with each percentile window of size
#   percentile_sampling for each cell

<linkcolor>
color_remap     = yes
color_autoremap = yes
<percentile 20>
color        = black
stroke_color = grey
</percentile>
<percentile 40>
color        = red
stroke_color = dred
</percentile>
<percentile 60>
color        = orange
stroke_color = dorange
</percentile>
<percentile 80>
color        = green
stroke_color = dgreen
</percentile>
<percentile 100>
color        = blue
stroke_color = dblue
</percentile>
</linkcolor>

# If you are using color_autoremap=yes above, then 
# define the percentile sampling window and 
# the start/end HSV color values. Percentile window
# colors are interpolated between this HSV pair.
#
# HSV = (hue saturation value) 
# hue=(0..360) saturation=(0..1) value=(0..1) 

percentile_sampling = 1

<colors>
h0 = 0
s0 = 0.5
v0 = 0.25
h1 = 180
s1 = 1
v1 = 1
</colors>

# You can control the color and stroke of ribbons for each
# quartile (q1, q2, q3, q4). Any values defined here will
# overwrite colors determined by remapping. 
#
# For example, if you have a lot of cells and wish to attenuate
# the visibility of ribbons associated with small values, you can
# set cell_q1_color=vvlgrey,cell_q1_nostroke=yes to fade the
# ribbons into the background.

#cell_q1_color    = vvlgrey
#cell_q2_color    = vlgrey
#cell_q3_color    = lgrey
#cell_q4_color    = red
#cell_q1_nostroke = yes
#cell_q2_nostroke = yes
#cell_q3_nostroke = yes
#cell_q4_nostroke = yes

# cell value multiplier, required when all data is small (e.g. <1), in which
# case set the multiplier to something like 1000 because Circos
# works only with integer scales

data_mult = 1

################################################################
# Segment labels can be optionally set to a size that is
# proportional to the size of the segment. Set min/max size
# values here. If this line is commented out, then the label
# size is determined by the circos.conf file used to draw the image

# segment_size_range       = 60,60

# progression controls how fast the label size changes from
# min to max (larger value of progression means values close to max
# are achieved for smaller segments)

segment_size_progression = 2

################################################################
# Segment colors can be specified in the data file (in this
# case use row_color_col and col_color_row), otherwise colors
# are interpolated within an HSV range. Color interpolation can be
# done in two ways: based on segment index (interpolation steps through
# colors uniformly for each segment) and total size (interpolation
# steps through colors in proportion to segment size).

<segment_colors>
interpolate_type = count # size or count
h0 = 0
s0 = 1
v0 = 1
h1 = 300
s1 = 1
v1 = 1
</segment_colors>

################################################################
# Shorten the labels of segments. Specify whether to do this
# with shorten_text=yes|no parameter and provide regular
# expressions in string_replace which define the text to
# replace. 

shorten_text = no

<string_replace>
chromosome = chr
</string_replace>

# exit on any error
strict_sanity = yes

# housekeeping
chr_prefix   = id
